"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertNode = exports.convertElementStyle = exports.convertStylesheet = exports.convertRule = void 0;
const node_html_parser_1 = require("node-html-parser");
const css_1 = __importDefault(require("css"));
const supportedStyles_1 = __importDefault(require("./supportedStyles"));
const camelize = require('camelize');
const convertRule = (rule, source = 'style') => {
    var _a;
    const declarations = ((_a = rule.declarations) === null || _a === void 0 ? void 0 : _a.filter((declaration) => declaration.type === 'declaration')) || [];
    return declarations
        .map((entry) => (Object.assign(Object.assign({}, entry), { property: camelize(entry.property) })))
        .reduce((style, { property, value }) => {
        if (property && value) {
            if (!property || !supportedStyles_1.default.includes(property)) {
                if ((property === 'background' && /^#?[a-zA-Z0-9]+$/.test(value)) ||
                    /^rgba?\([0-9, ]+\)$/i.test(value) ||
                    /^hsla?\([0-9.%, ]+\)$/i.test(value)) {
                    property = 'backgroundColor';
                }
                else {
                    console.warn(`${source}: Found unsupported style "${property}"`, {
                        property,
                        value,
                    });
                }
            }
            style[property] = value;
        }
        return style;
    }, {});
};
exports.convertRule = convertRule;
const convertStylesheet = (stylesheet) => {
    var _a, _b;
    const response = {};
    try {
        const parsed = css_1.default.parse(stylesheet);
        const rules = ((_b = (_a = parsed.stylesheet) === null || _a === void 0 ? void 0 : _a.rules) === null || _b === void 0 ? void 0 : _b.filter((rule) => rule.type === 'rule')) || [];
        rules.forEach((rule) => {
            var _a;
            const style = exports.convertRule(rule);
            (_a = rule.selectors) === null || _a === void 0 ? void 0 : _a.forEach((selector) => {
                response[selector] = style;
            });
        });
    }
    catch (e) {
        console.error(`Error parsing stylesheet: "${stylesheet}"`, e);
    }
    return response;
};
exports.convertStylesheet = convertStylesheet;
const convertElementStyle = (styleAttr, tag) => {
    var _a, _b;
    try {
        const parsed = css_1.default.parse(`${tag} { ${styleAttr} }`, {
            source: tag,
        });
        const rules = ((_b = (_a = parsed.stylesheet) === null || _a === void 0 ? void 0 : _a.rules) === null || _b === void 0 ? void 0 : _b.filter((rule) => rule.type === 'rule')) || [];
        const firstRule = rules.shift();
        return firstRule ? exports.convertRule(firstRule, tag) : undefined;
    }
    catch (e) {
        console.error(`Error parsing style attribute "${styleAttr}" for tag: ${tag}`, e);
    }
};
exports.convertElementStyle = convertElementStyle;
const convertNode = (node) => {
    if (node.nodeType === node_html_parser_1.NodeType.TEXT_NODE) {
        return node.rawText;
    }
    if (node.nodeType === node_html_parser_1.NodeType.COMMENT_NODE) {
        return '';
    }
    if (node.nodeType !== node_html_parser_1.NodeType.ELEMENT_NODE) {
        throw new Error('Not sure what this is');
    }
    const html = node;
    const content = html.childNodes.map(exports.convertNode);
    const kindCounters = {};
    content.forEach((child) => {
        if (typeof child !== 'string') {
            child.indexOfType =
                child.tag in kindCounters
                    ? (kindCounters[child.tag] = kindCounters[child.tag] + 1)
                    : (kindCounters[child.tag] = 0);
        }
    });
    let style;
    if (html.attributes.style && html.attributes.style.trim()) {
        style = exports.convertElementStyle(html.attributes.style, html.tagName);
    }
    return Object.assign(html, {
        tag: (html.tagName || '').toLowerCase(),
        style: style ? [style] : [],
        content,
        indexOfType: 0,
    });
};
exports.convertNode = convertNode;
const parseHtml = (text) => {
    const html = node_html_parser_1.parse(text, { comment: false });
    const stylesheets = html
        .querySelectorAll('style')
        .map((styleNode) => styleNode.childNodes.map((textNode) => textNode.rawText.trim()).join('\n'))
        .filter((styleText) => !!styleText)
        .map(exports.convertStylesheet);
    return {
        stylesheets,
        rootElement: exports.convertNode(html),
    };
};
exports.default = parseHtml;
//# sourceMappingURL=parse.js.map